"""Flask application for OLASIS 4.0.

This module defines a small web server that powers the OLASIS 4.0
interface.  It exposes three routes:

* ``/`` – serves the main HTML page.  The front‑end layout and styling
  are defined in ``templates/index.html`` and must not be changed
  programmatically.  The page includes all of the original CSS from
  ``Olasis4.html`` so that the visual look and feel remains the same.

* ``/api/search`` – returns search results from OpenAlex and ORCID in
  JSON format.  The front‑end issues a GET request to this endpoint
  whenever the user submits a search.  Two lists are returned: one
  containing article metadata (title, authors, year, DOI and OpenAlex ID)
  and another containing specialist profiles (ORCID identifier, name and
  profile URL).

* ``/api/chat`` – accepts a user message via POST and returns a
  response generated by Google’s Gemini generative AI.  The back‑end
  integrates with the ``olasis.Chatbot`` wrapper which reads the API
  key from the ``GOOGLE_API_KEY`` environment variable.  If the key is
  missing or the ``google‑genai`` package is not installed, the
  chatbot falls back to an informative error message.

Usage
-----

Install the dependencies listed in ``requirements.txt`` and set
``GOOGLE_API_KEY`` in your environment.  Then run

::

    python app.py

The server will start on port 5000 by default.  Visit
``http://localhost:5000`` in your browser to use the application.
"""

from __future__ import annotations

import os
from flask import Flask, jsonify, render_template, request
from dotenv import load_dotenv

from olasis import Chatbot, search_articles, search_specialists

# Carregar variáveis de ambiente do arquivo .env
load_dotenv()


def create_app() -> Flask:
    """Factory to create and configure the Flask application.

    Returns
    -------
    Flask
        A configured Flask application instance.
    """
    app = Flask(
        __name__,
        template_folder="templates",
        static_folder="static",
    )

    # Initialise the chatbot once at start‑up.  The API key will be read
    # from the environment variable GOOGLE_API_KEY.  If the key is not
    # provided the Chatbot will respond with an error message.
    chatbot = Chatbot(api_key=os.getenv("GOOGLE_API_KEY"), model="gemini-2.5-flash")

    @app.route("/")
    def index() -> str:
        """Render the main search page.

        The HTML template is a verbatim copy of the original
        ``Olasis4.html`` file with only minor additions to include
        external JavaScript.  Any changes to the look and feel should be
        done in the template, not in Python.
        """
        return render_template("index.html")

    @app.route("/api/search")
    def api_search() -> tuple[dict[str, object], int] | tuple[dict[str, str], int]:
        """Perform a combined search across OpenAlex and ORCID.

        Expects a ``q`` query parameter containing the user’s search
        string.  Returns a JSON object with two lists: ``articles`` and
        ``specialists``.  Each article is represented as a dictionary
        containing the keys ``title``, ``authors``, ``year``, ``openalex_id``
        and ``doi``.  Each specialist contains ``orcid``, ``given_names``,
        ``family_names``, ``full_name`` and ``profile_url``.
        """
        query: str = request.args.get("q", "").strip()
        if not query:
            return {"error": "No search query provided."}, 400
        # Limit the number of results to a reasonable default.  The
        # underlying modules cap values internally as well.
        articles = search_articles(query, per_page=5)
        specialists = search_specialists(query, rows=5)
        return {"articles": articles, "specialists": specialists}, 200

    @app.route("/api/chat", methods=["POST"])
    def api_chat() -> tuple[dict[str, str], int]:
        """Generate a chatbot response to the user’s message.

        The request body must be JSON with a ``message`` key.  A 400
        status code will be returned if the message is missing or
        blank.  Otherwise the Gemini API is queried via the Chatbot
        wrapper and the resulting text is returned in the ``response``
        field.
        """
        data = request.get_json(silent=True) or {}
        message: str = (data.get("message") or "").strip()
        if not message:
            return {"response": "Por favor, proporcione un mensaje."}, 400
        # Ask the chatbot for a response.  If the API call fails the
        # wrapper will return an informative fallback message.
        reply = chatbot.ask(message)
        return {"response": reply}, 200

    return app


if __name__ == "__main__":
    # When executed directly, create the application and run it.
    # In production a WSGI server such as gunicorn or uwsgi should be
    # used instead.
    app = create_app()
    port = int(os.getenv("PORT", 5000))
    app.run(host="0.0.0.0", port=port, debug=False)